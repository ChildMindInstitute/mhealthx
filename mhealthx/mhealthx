#!/usr/bin/env python
"""
This pipeline runs feature extraction on mHealth data stored on Synapse.org.

Example to prepare the first three rows of mhealth data from Synapse:

    mhealthx --setup --phonation syn4590865 \
                     --balance syn4590866 \
                     --tapping syn4590864 \
                     --dependencies /software --rows 3

Example to extract features from the above three rows:

    mhealthx --phonation syn4590865 \
             --balance syn4590866 \
             --tapping syn4590864 \
             --dependencies /software --rows 3

- First-time use on a given machine: include -u and -p for Synapse login.
- Replace -d argument with path to installed feature extraction software.

For help in using mhealthx ::

    - README file
    - Help on the command line::

        $ mhealthx --help

This file uses Nipype (http://www.nipy.org/nipype/) to create a workflow
environment that enables mhealthx to run in a flexible, modular manner
while storing provenance information.

Authors:
    - Arno Klein, 2015  (arno@sagebase.org)  http://binarybottle.com

Copyright 2015,  Sage Bionetworks (http://sagebase.org), Apache v2.0 License

"""

import os
import sys
import argparse
from nipype import config, logging
from nipype.interfaces.io import DataSink
from nipype.interfaces.utility import Function as Fn
from nipype.pipeline.engine import Workflow, Node
from mhealthx.extract import run_openSMILE, run_pyGait
from mhealthx.xio import extract_synapse_rows, get_convert_audio, get_accel, \
    write_wav

# ============================================================================
#
# Command-line arguments
#
# ============================================================================
parser = argparse.ArgumentParser(description="""
                    Extract features from mHealth data
                    stored on Sage Bionetwork's Synapse.org.
                    Example: mhealthx --phonation syn4590865 -d /software
                    (-d: path to installed software dependencies; -u, -p:
                    Synapse login for first use on a given machine)
""",
                                 formatter_class = lambda prog:
                                 argparse.HelpFormatter(prog,
                                                        max_help_position=40))
parser.add_argument("-v", "--version", help="version number",
                    action='version', version='%(prog)s 0.1')
parser.add_argument("-n", "--numproc",
                    help='number of processors (default: 1)',
                    type=int, default=1, metavar='INT')
parser.add_argument("-r", "--rows",
                    help='download this number of rows of the Synapse tables',
                    type=int, metavar='INT', default=sys.maxint)
parser.add_argument("-g", "--graph",
                    help='plot workflow graph: "hier", "flat", "exec"',
                    choices=['hier', 'flat', 'exec'], metavar='STR')
parser.add_argument('--reports', dest='reports', action='store_true',
                    help='generate nipype reports')
parser.add_argument("--plugin", dest="plugin",
                    default='Linear',
                    help="optional plugin: --plugin PBS")
parser.add_argument("--plugin_args", dest="plugin_args",
                    help="optional plugin arguments:"
                         " --plugin_args \"dict(qsub_args='-q many')\"")
setup_group = parser.add_argument_group('setup')
setup_group.add_argument("-s", "--setup",
                         help="setup: download mhealth data",
                         action='store_true')
setup_group.add_argument("-d", "--dependencies",
                         help="path to software dependencies",
                         metavar='STR')
setup_group.add_argument("-u", "--username",
                         help="Synapse username", metavar='STR')
setup_group.add_argument("-p", "--password",
                         help="Synapse password", metavar='STR')
activities_group = parser.add_argument_group('activities')
activities_group.add_argument("--phonation",
                              help="Synapse table ID for phonation data",
                              metavar='STR')
activities_group.add_argument("--balance",
                              help="Synapse table ID for balance data",
                              metavar='STR')
activities_group.add_argument("--tapping",
                              help="Synapse table ID for tapping data",
                              metavar='STR')
outputs_group = parser.add_argument_group('outputs')
outputs_group.add_argument("-o", "--outputs",
                           help='output folder (if not $HOME/mhealthx_output)',
                           default=os.path.join(os.environ['HOME'],
                                                'mhealthx_output'),
                           metavar='STR')
outputs_group.add_argument("-c", "--cache",
                           help="cache folder (if not $HOME/mhealthx_cache)",
                           default=os.path.join(os.environ['HOME'],
                                                'mhealthx_cache'),
                           metavar='STR')
outputs_group.add_argument("-t", "--temp",
                           help='temp folder (if not same as --cache)',
                           metavar='STR')
args = parser.parse_args()
username = args.username
password = args.password
dependencies = args.dependencies
setup_rows = args.setup
if args.temp:
    temporary_path = args.temp
else:
    temporary_path = args.cache
synID_phonation = args.phonation
synID_balance = args.balance
synID_tapping = args.tapping
if args.numproc:
    nproc = args.numproc
else:
    nproc = 1

# ============================================================================
#
# Third-party software setup
#
# ============================================================================
# openSMILE information:
smile_v2_1 = 'openSMILE-2.1.0'
smile_v2_2 = 'openSMILE-2.2rc1'
smile_config1 = 'IS13_ComParE.conf'
smile_config2 = os.path.join('gemaps', 'GeMAPSv01a_core.lld.conf.inc')
smile_string1 = '_features_{0}_{1}'.format(smile_v2_1, smile_config1)
if dependencies:
    smile_config_file1 = os.path.join(dependencies, smile_v2_1,
                                      'config', smile_config1)
else:
    raise Warning("dependencies not set -- cannot run openSMILE!")

# ============================================================================
#
# Login once to Synapse and cache credentials
#
# ============================================================================
import synapseclient
syn = synapseclient.Synapse()
syn.login(username, password, rememberMe=True)

# ============================================================================
#
# Initialize main workflow and create output directories
#
# ============================================================================
main_workflow_name = 'mhealthx'
Flow = Workflow(name=main_workflow_name)
Flow.base_dir = args.cache
Sink = Node(DataSink(), name='Results')
Sink.inputs.base_directory = args.outputs
if not os.path.isdir(args.outputs):
    print("Create missing output directory: {0}".format(args.outputs))
    os.makedirs(args.outputs)
if not os.path.isdir(args.cache):
    print("Create missing cache directory: {0}".format(args.cache))
    os.makedirs(args.cache)
feature_table_path = os.path.join(args.outputs, 'feature_tables')
if not os.path.isdir(feature_table_path):
    os.makedirs(feature_table_path)
row_path = os.path.join(args.cache, main_workflow_name)
path_phonation = os.path.join(row_path, 'row_files_phonation')
path_balance = os.path.join(row_path, 'row_files_balance')
path_walking = os.path.join(row_path, 'row_files_walking')
path_tapping = os.path.join(row_path, 'row_files_tapping')

# ============================================================================
#
# Phonation (microphone)
#
# ============================================================================
if synID_phonation and setup_rows:
    if not os.path.isdir(path_phonation):
        os.makedirs(path_phonation)

    # ------------------------------------------------------------------------
    # Retrieve information about all phonation files in Synapse table:
    # ------------------------------------------------------------------------
    GetPhonationRows = Node(name='retrieve_phonation_rows',
                            interface=Fn(function=extract_synapse_rows,
                                         input_names=['synapse_table',
                                                      'save_path',
                                                      'limit',
                                                      'username',
                                                      'password'],
                                         output_names=['row_data',
                                                       'row_files']))
    Flow.add_nodes([GetPhonationRows])
    GetPhonationRows.inputs.synapse_table = synID_phonation
    GetPhonationRows.inputs.save_path = path_phonation
    if args.rows:
        GetPhonationRows.inputs.limit = args.rows
    else:
        GetPhonationRows.inputs.limit = None
    GetPhonationRows.inputs.username = ''
    GetPhonationRows.inputs.password = ''

elif synID_phonation and not setup_rows:
    rows_phonate = [os.path.join(path_phonation, f)
                    for i, f in enumerate(sorted(os.listdir(path_phonation)))
                    if i < args.rows
                    and os.path.isfile(os.path.join(path_phonation, f))]

    # ------------------------------------------------------------------------
    # Phonation data:
    # 1. Retrieve each row + audio file from a Synapse table.
    # 2. Convert voice file to .wav format.
    # ------------------------------------------------------------------------
    getPhonation = Node(name='phonation_data',
                        interface=Fn(function=get_convert_audio,
                                     input_names=['synapse_table',
                                                  'row',
                                                  'column_name',
                                                  'convert_file_append',
                                                  'convert_command',
                                                  'convert_input_args',
                                                  'convert_output_args',
                                                  'out_path',
                                                  'username',
                                                  'password'],
                                     output_names=['row',
                                                   'new_file']))
    getPhonation.inputs.synapse_table = synID_phonation
    getPhonation.iterables = ("row", rows_phonate)
    getPhonation.inputs.column_name = 'audio_audio.m4a'
    getPhonation.inputs.convert_file_append = '.wav'
    getPhonation.inputs.convert_command = 'ffmpeg'
    getPhonation.inputs.convert_input_args = '-y -i'
    getPhonation.inputs.convert_output_args = '-ac 2'
    getPhonation.inputs.out_path = '.'
    getPhonation.inputs.username = ''
    getPhonation.inputs.password = ''

    # ------------------------------------------------------------------------
    # Repeat for phonation countdown data:
    # ------------------------------------------------------------------------
    getPhonation0 = getPhonation.clone('phonation_countdown_data')
    getPhonation0.inputs.column_name = 'audio_countdown.m4a'

    # ------------------------------------------------------------------------
    # openSMILE on phonation data:
    # 1. Run openSMILE's SMILExtract audio feature extraction command.
    # 2. Construct a feature row from the original and openSMILE rows.
    # 3. Write the feature row to a table or append to a feature table.
    # ------------------------------------------------------------------------
    SMILEphonation = Node(name='openSMILE_phonation',
                          interface=Fn(function=run_openSMILE,
                                       input_names=['audio_file',
                                                    'command',
                                                    'flag1',
                                                    'flags',
                                                    'flagn',
                                                    'args',
                                                    'closing',
                                                    'row',
                                                    'table_stem',
                                                    'save_rows'],
                                       output_names=['feature_row',
                                                     'feature_table']))
    Flow.connect(getPhonation, 'new_file', SMILEphonation, 'audio_file')
    Flow.connect(getPhonation, 'row', SMILEphonation, 'row')
    SMILEphonation.inputs.command = 'SMILExtract'
    SMILEphonation.inputs.flag1 = '-I'
    SMILEphonation.inputs.flags = '-C'
    SMILEphonation.inputs.flagn = '-csvoutput'
    SMILEphonation.inputs.args = smile_config_file1
    SMILEphonation.inputs.closing = '-nologfile 1'
    SMILEphonation.inputs.table_stem = \
        os.path.join(feature_table_path, 'phonation{0}'.format(smile_string1))
    SMILEphonation.inputs.save_rows = True

    # ------------------------------------------------------------------------
    # Repeat for phonation countdown data:
    # ------------------------------------------------------------------------
    SMILEphonation0 = SMILEphonation.clone('openSMILE_phonation_countdown')
    Flow.connect(getPhonation0, 'new_file', SMILEphonation0, 'audio_file')
    Flow.connect(getPhonation0, 'row', SMILEphonation0, 'row')
    SMILEphonation0.inputs.table_stem = os.path.join(feature_table_path,
        'phonation_countdown{0}'.format(smile_string1))

# ============================================================================
#
# Balance (accelerometer)
#
# ============================================================================
if synID_balance and setup_rows:
    if not os.path.isdir(path_balance):
        os.makedirs(path_balance)

    # ------------------------------------------------------------------------
    # Retrieve information about all balance files in Synapse table:
    # ------------------------------------------------------------------------
    GetBalanceRows = GetPhonationRows.clone('retrieve_balance_rows')
    GetBalanceRows.inputs.synapse_table = synID_balance
    GetBalanceRows.inputs.save_path = path_balance
    Flow.add_nodes([GetBalanceRows])

if synID_balance and not setup_rows:
    rows_balance = [os.path.join(path_balance, f)
                    for i, f in enumerate(sorted(os.listdir(path_balance)))
                    if i < args.rows
                    and os.path.isfile(os.path.join(path_balance, f))]

    # ------------------------------------------------------------------------
    # Balance data: retrieve each row + json file from Synapse table:
    # ------------------------------------------------------------------------
    getBalance = Node(name='balance_data',
                      interface=Fn(function=get_accel,
                                   input_names=['synapse_table',
                                                'row',
                                                'column_name',
                                                'start',
                                                'out_path',
                                                'username',
                                                'password'],
                                   output_names=['x',
                                                 'y',
                                                 'z',
                                                 't',
                                                 'sample_rate',
                                                 'duration',
                                                 'row',
                                                 'file_path']))
    getBalance.inputs.synapse_table = synID_balance
    getBalance.iterables = ("row", rows_balance)
    getBalance.inputs.column_name = 'accel_walking_rest.json.items'
    getBalance.inputs.start = 150
    getBalance.inputs.out_path = '.'
    getBalance.inputs.username = ''
    getBalance.inputs.password = ''

    # ------------------------------------------------------------------------
    # Repeat for walking data:
    # ------------------------------------------------------------------------
    getWalking = Node(name='walking_data',
                      interface=Fn(function=get_accel,
                                   input_names=['synapse_table',
                                                'row',
                                                'column_name',
                                                'start',
                                                'out_path',
                                                'username',
                                                'password'],
                                   output_names=['x',
                                                 'y',
                                                 'z',
                                                 't',
                                                 'sample_rate',
                                                 'duration',
                                                 'row',
                                                 'file_path']))
    getWalking.inputs.synapse_table = synID_balance
    getWalking.iterables = ("row", rows_balance)
    getWalking.inputs.column_name = 'accel_walking_outbound.json.items'
    getWalking.inputs.start = 150
    getWalking.inputs.out_path = '.'
    getWalking.inputs.username = ''
    getWalking.inputs.password = ''

    # ------------------------------------------------------------------------
    # pyGait on walking data:
    # ------------------------------------------------------------------------
    pyGaitWalk = Node(name='pyGait_walking',
                      interface=Fn(function=run_pyGait,
                                   input_names=['x',
                                                'y',
                                                'z',
                                                't',
                                                'sample_rate',
                                                'duration',
                                                'threshold',
                                                'order',
                                                'cutoff',
                                                'row',
                                                'file_path',
                                                'table_stem',
                                                'save_rows'],
                                   output_names=['feature_row',
                                                 'feature_table']))
    Flow.connect(getWalking, 'x', pyGaitWalk, 'x')
    Flow.connect(getWalking, 'y', pyGaitWalk, 'y')
    Flow.connect(getWalking, 'z', pyGaitWalk, 'z')
    Flow.connect(getWalking, 't', pyGaitWalk, 't')
    Flow.connect(getWalking, 'sample_rate', pyGaitWalk, 'sample_rate')
    Flow.connect(getWalking, 'duration', pyGaitWalk, 'duration')
    pyGaitWalk.inputs.threshold = 0.2
    pyGaitWalk.inputs.order = 4
    pyGaitWalk.inputs.cutoff = 5
    Flow.connect(getWalking, 'row', pyGaitWalk, 'row')
    Flow.connect(getWalking, 'file_path', pyGaitWalk, 'file_path')
    pyGaitWalk.inputs.column_name = 'accel_walking_rest.json.items'
    pyGaitWalk.inputs.table_stem = os.path.join(feature_table_path,
                                                  'walking_pyGait')
    pyGaitWalk.inputs.save_rows = True

    # ------------------------------------------------------------------------
    # Convert balance data from json to wav format for each axis:
    # ------------------------------------------------------------------------
    WAVbalanceX = Node(name='convert_balance_x_to_wav',
                       interface=Fn(function=write_wav,
                                    input_names=['data',
                                                 'file_stem',
                                                 'file_append',
                                                 'sample_rate',
                                                 'amplitude'],
                                    output_names=['wav_file']))
    WAVbalanceX.inputs.amplitude = 32700
    WAVbalanceY = WAVbalanceX.clone('convert_balance_y_to_wav')
    WAVbalanceZ = WAVbalanceX.clone('convert_balance_z_to_wav')
    Flow.connect(getBalance, 'x', WAVbalanceX, 'data')
    Flow.connect(getBalance, 'y', WAVbalanceY, 'data')
    Flow.connect(getBalance, 'z', WAVbalanceZ, 'data')
    Flow.connect(getBalance, 'file_path', WAVbalanceX, 'file_stem')
    Flow.connect(getBalance, 'file_path', WAVbalanceY, 'file_stem')
    Flow.connect(getBalance, 'file_path', WAVbalanceZ, 'file_stem')
    WAVbalanceX.inputs.file_append = '_balance_x.wav'
    WAVbalanceY.inputs.file_append = '_balance_y.wav'
    WAVbalanceZ.inputs.file_append = '_balance_z.wav'
    Flow.connect(getBalance, 'sample_rate', WAVbalanceX, 'sample_rate')
    Flow.connect(getBalance, 'sample_rate', WAVbalanceY, 'sample_rate')
    Flow.connect(getBalance, 'sample_rate', WAVbalanceZ, 'sample_rate')

    # ------------------------------------------------------------------------
    # Repeat for walking data:
    # ------------------------------------------------------------------------
    WAVwalkingX = Node(name='convert_walking_x_to_wav',
                       interface=Fn(function=write_wav,
                                    input_names=['data',
                                                 'file_stem',
                                                 'file_append',
                                                 'sample_rate',
                                                 'amplitude'],
                                    output_names=['wav_file']))
    WAVwalkingX.inputs.amplitude = 32700
    WAVwalkingY = WAVwalkingX.clone('convert_walking_y_to_wav')
    WAVwalkingZ = WAVwalkingX.clone('convert_walking_z_to_wav')
    Flow.connect(getWalking, 'x', WAVwalkingX, 'data')
    Flow.connect(getWalking, 'y', WAVwalkingY, 'data')
    Flow.connect(getWalking, 'z', WAVwalkingZ, 'data')
    Flow.connect(getBalance, 'file_path', WAVwalkingX, 'file_stem')
    Flow.connect(getBalance, 'file_path', WAVwalkingY, 'file_stem')
    Flow.connect(getBalance, 'file_path', WAVwalkingZ, 'file_stem')
    WAVwalkingX.inputs.file_append = '_walking_x.wav'
    WAVwalkingY.inputs.file_append = '_walking_y.wav'
    WAVwalkingZ.inputs.file_append = '_walking_z.wav'
    Flow.connect(getBalance, 'sample_rate', WAVwalkingX, 'sample_rate')
    Flow.connect(getBalance, 'sample_rate', WAVwalkingY, 'sample_rate')
    Flow.connect(getBalance, 'sample_rate', WAVwalkingZ, 'sample_rate')

    # ------------------------------------------------------------------------
    # openSMILE on each axis of balance data:
    # 1. Run openSMILE's SMILExtract audio feature extraction command.
    # 2. Construct a feature row from the original and openSMILE rows.
    # 3. Write the feature row to a table or append to a feature table.
    # ------------------------------------------------------------------------
    SMILEbalanceX = Node(name='openSMILE_balance_x',
                         interface=Fn(function=run_openSMILE,
                                      input_names=['audio_file',
                                                   'command',
                                                   'flag1',
                                                   'flags',
                                                   'flagn',
                                                   'args',
                                                   'closing',
                                                   'row',
                                                   'table_stem',
                                                   'save_rows'],
                                      output_names=['feature_row',
                                                    'feature_table']))
    SMILEbalanceX.inputs.command = 'SMILExtract'
    SMILEbalanceX.inputs.flag1 = '-I'
    SMILEbalanceX.inputs.flags = '-C'
    SMILEbalanceX.inputs.flagn = '-csvoutput'
    SMILEbalanceX.inputs.args = smile_config_file1
    SMILEbalanceX.inputs.closing = '-nologfile 1'
    SMILEbalanceX.inputs.save_rows = True

    SMILEbalanceY = SMILEbalanceX.clone('openSMILE_balance_y')
    SMILEbalanceZ = SMILEbalanceX.clone('openSMILE_balance_z')
    Flow.connect(WAVbalanceX, 'wav_file', SMILEbalanceX, 'audio_file')
    Flow.connect(WAVbalanceY, 'wav_file', SMILEbalanceY, 'audio_file')
    Flow.connect(WAVbalanceZ, 'wav_file', SMILEbalanceZ, 'audio_file')
    Flow.connect(getBalance, 'row', SMILEbalanceX, 'row')
    Flow.connect(getBalance, 'row', SMILEbalanceY, 'row')
    Flow.connect(getBalance, 'row', SMILEbalanceZ, 'row')
    SMILEbalanceX.inputs.table_stem = \
        os.path.join(feature_table_path, 'balance_x{0}'.format(smile_string1))
    SMILEbalanceY.inputs.table_stem = \
        os.path.join(feature_table_path, 'balance_y{0}'.format(smile_string1))
    SMILEbalanceZ.inputs.table_stem = \
        os.path.join(feature_table_path, 'balance_z{0}'.format(smile_string1))

    # ------------------------------------------------------------------------
    # Repeat for walking data:
    # ------------------------------------------------------------------------
    SMILEwalkingX = Node(name='openSMILE_walking_x',
                         interface=Fn(function=run_openSMILE,
                                      input_names=['audio_file',
                                                   'command',
                                                   'flag1',
                                                   'flags',
                                                   'flagn',
                                                   'args',
                                                   'closing',
                                                   'row',
                                                   'table_stem',
                                                   'save_rows'],
                                      output_names=['feature_row',
                                                    'feature_table']))
    SMILEwalkingX.inputs.command = 'SMILExtract'
    SMILEwalkingX.inputs.flag1 = '-I'
    SMILEwalkingX.inputs.flags = '-C'
    SMILEwalkingX.inputs.flagn = '-csvoutput'
    SMILEwalkingX.inputs.args = smile_config_file1
    SMILEwalkingX.inputs.closing = '-nologfile 1'
    SMILEwalkingX.inputs.save_rows = True

    #SMILEwalkingX = SMILEbalanceX.clone('openSMILE_walking_x')
    SMILEwalkingY = SMILEwalkingX.clone('openSMILE_walking_y')
    SMILEwalkingZ = SMILEwalkingX.clone('openSMILE_walking_z')
    Flow.connect(WAVwalkingX, 'wav_file', SMILEwalkingX, 'audio_file')
    Flow.connect(WAVwalkingY, 'wav_file', SMILEwalkingY, 'audio_file')
    Flow.connect(WAVwalkingZ, 'wav_file', SMILEwalkingZ, 'audio_file')
    Flow.connect(getWalking, 'row', SMILEwalkingX, 'row')
    Flow.connect(getWalking, 'row', SMILEwalkingY, 'row')
    Flow.connect(getWalking, 'row', SMILEwalkingZ, 'row')
    SMILEwalkingX.inputs.table_stem = \
        os.path.join(feature_table_path, 'walking_x{0}'.format(smile_string1))
    SMILEwalkingY.inputs.table_stem = \
        os.path.join(feature_table_path, 'walking_y{0}'.format(smile_string1))
    SMILEwalkingZ.inputs.table_stem = \
        os.path.join(feature_table_path, 'walking_z{0}'.format(smile_string1))

# ============================================================================
#
# Tapping (touchscreen)
#
# ============================================================================
if synID_tapping and setup_rows:
    if not os.path.isdir(path_tapping):
        os.makedirs(path_tapping)

    # ------------------------------------------------------------------------
    # Retrieve information about all tapping files in Synapse table:
    # ------------------------------------------------------------------------
    GetTappingRows = GetPhonationRows.clone('retrieve_tapping_rows')
    GetTappingRows.inputs.synapse_table = synID_tapping
    GetTappingRows.inputs.save_path = path_tapping
    Flow.add_nodes([GetTappingRows])

elif synID_tapping and not setup_rows:

    pass


# ============================================================================
#
# Run workflows
#
# ============================================================================
if __name__ == '__main__':

    from time import time
    time0 = time()

    # ------------------------------------------------------------------------
    # Workflow configuration: provenance tracking, content hashing, etc.:
    # ------------------------------------------------------------------------
    # config.enable_provenance()
    Flow.config['execution']['hash_method'] = 'timestamp'
    Flow.config['execution']['local_hash_check'] = False
    Flow.config['execution']['create_report'] = args.reports

    # ------------------------------------------------------------------------
    # Generate a visual graph:
    # ------------------------------------------------------------------------
    graph_vis = args.graph
    if graph_vis:
        if graph_vis == 'exec':
            Flow.write_graph(graph2use=graph_vis, simple_form=False)
        else:
            if graph_vis == 'hier':
                graph_vis = 'hierarchical'
            Flow.write_graph(graph2use=graph_vis)

    # ------------------------------------------------------------------------
    # Debug: http://nipy.org/nipype/users/config_file.html#debug-configuration
    # ------------------------------------------------------------------------
    debug = False
    if debug:
        config.set('logging', 'workflow_level', 'DEBUG')
        logging.update_logging(config)
        Flow.config['execution']['stop_on_first_rerun'] = True
        nproc = 1

    # ------------------------------------------------------------------------
    # Run with or without a plugin:
    # Ex: workflow.run(plugin='SGEGraph',
    #                  plugin_args = {'dont_resubmit_completed_jobs': True})
    # ------------------------------------------------------------------------
    if args.plugin:
        if args.plugin_args:
            Flow.run(plugin=args.plugin, plugin_args=eval(args.plugin_args))
        else:
            Flow.run(plugin=args.plugin)
    elif nproc > 1:
        Flow.run(plugin='MultiProc',
                 plugin_args={'n_procs': nproc})
    else:
        Flow.run()  # Use all processors: Flow.run(plugin='MultiProc')

    print('Done! ({0:0.2f} seconds)'.format(time() - time0))




# ------------------------------------------------------------------------
# Store openSMILE features to its own Synapse table:
# ------------------------------------------------------------------------
# SaveOpenSMILE = JoinNode(name='save_openSMILE',
#                          joinsource='OpenSMILE',
#                          joinfield='dataframes',
#                          interface=Fn(function=dataframes_to_csv_file,
#                                       input_names=['dataframes',
#                                                    'csv_file'],
#                                       output_names=['table_data',
#                                                     'csv_file']))
# Flow.connect(FormatOpenSMILE, 'feature_table',
#              SaveOpenSMILE, 'dataframes')
# SaveOpenSMILE.inputs.csv_file = 'openSMILE_IS13_ComParE.csv'
# Flow.connect(SaveOpenSMILE, 'csv_file', Sink, 'phonation.@features')

# ------------------------------------------------------------------------
# Store openSMILE features to its own Synapse table:
# FIX: WOULD NEED TO REORGANIZE: | feature | statistical summary | value |
# ------------------------------------------------------------------------
# SaveOpenSMILE = Node(name='save_openSMILE',
#              interface=Fn(function=concatenate_tables_to_synapse_table,
#                           input_names=['tables',
#                                        'synapse_project_id',
#                                        'table_name',
#                                        'username',
#                                        'password'],
#                           output_names=['table_data',
#                                         'table_name',
#                                         'synapse_table_id',
#                                         'synapse_project_id']))
# Flow.connect(FormatOpenSMILE, 'feature_table', SaveOpenSMILE, 'tables')
# SaveOpenSMILE.inputs.synapse_project_id = 'syn4899451'
# SaveOpenSMILE.inputs.table_name = 'Phonation openSMILE feature table'
# SaveOpenSMILE.inputs.username = ''
# SaveOpenSMILE.inputs.password = ''

# ------------------------------------------------------------------------
# Store openSMILE output file handle to the mPower phonation file table:
# ------------------------------------------------------------------------
# StoreOpenSMILE = Node(name='store_openSMILE',
#                       interface=Fn(function=file_to_synapse_table,
#                                    input_names=['feature_file',
#                                                 'raw_feature_file',
#                                                 'source_file_id',
#                                                 'provenance_activity_id',
#                                                 'command_line',
#                                                 'synapse_table_id',
#                                                 'username',
#                                                 'password'],
#                                    output_names=[]))
# Flow.connect(SaveOpenSMILE, 'csv_file',
#              StoreOpenSMILE, 'feature_file')
# Flow.connect(OpenSMILE, 'argn',
#              StoreOpenSMILE, 'raw_feature_file')
# StoreOpenSMILE.inputs.provenance_activity_id = ''
# #Flow.connect(OpenSMILE, 'argn',
# #             StoreOpenSMILE, 'source_file_id')
# StoreOpenSMILE.inputs.source_file_id = ''
# Flow.connect(OpenSMILE, 'command_line',
#              StoreOpenSMILE, 'command_line')
# Flow.connect(PrepPhonation, 'synapse_table_id',
#              StoreOpenSMILE, 'synapse_table_id')
# StoreOpenSMILE.inputs.username = ''
# StoreOpenSMILE.inputs.password = ''

