#!/usr/bin/env python
"""
This pipeline runs feature extraction on mHealth data stored on Synapse.org.

Example: mhealthx --phonation syn4590865 -t /home/arno/software/audio

- First-time use on a given machine: include -u and -p for Synapse login.
- Replace -t argument with path to installed feature extraction software.

For help in using mhealthx ::

    - README file
    - Help on the command line::

        $ mhealthx --help

This file uses Nipype (http://www.nipy.org/nipype/) to create a workflow
environment that enables mhealthx to run in a flexible, modular manner
while storing provenance information.

Authors:
    - Arno Klein, 2015  (arno@sagebase.org)  http://binarybottle.com

Copyright 2015,  Sage Bionetworks (http://sagebase.org), Apache v2.0 License

"""

import os
import argparse
from nipype import config, logging
from nipype.interfaces.io import DataSink
from nipype.interfaces.utility import Function as Fn
from nipype.pipeline.engine import Workflow, Node, MapNode
from mhealthx.data_io import convert_audio_file, arff_to_csv, tables_to_csv
from mhealthx.synapse_io import extract_rows, read_files_from_row
from mhealthx.utils import rename_file, run_command

# ============================================================================
#
# Command-line arguments
#
# ============================================================================
parser = argparse.ArgumentParser(description="""
                    Extract features from mHealth data
                    stored on Sage Bionetwork's Synapse.org.
                    Example: mhealthx --phonation syn4590865 -t /software
                    (-t: path to installed third-party software; -u, -p:
                    Synapse login for first use on a given machine)
""",
                    formatter_class = lambda prog:
                    argparse.HelpFormatter(prog, max_help_position=40))
parser.add_argument("-v", "--version", help="version number",
                    action='version', version='%(prog)s 0.1')
parser.add_argument("-n", "--numproc",
                    help=('number of processors (default: 1)'),
                    type=int, default=1, metavar='INT')
parser.add_argument("-g", "--graph",
                    help=('plot workflow graph: "hier", "flat", "exec"'),
                    choices=['hier', 'flat', 'exec'], metavar='STR')
parser.add_argument("--plugin", dest="plugin",
                    default='Linear',
                    help="optional plugin: --plugin PBS")
parser.add_argument("--plugin_args", dest="plugin_args",
                    help="optional plugin arguments:"
                         " --plugin_args \"dict(qsub_args='-q many')\"")
setup_group = parser.add_argument_group('setup')
setup_group.add_argument("-t", "--thirdparty",
                    help="path to third-party software",
                    metavar='STR')
setup_group.add_argument("-u", "--username",
                    help="Synapse username",
                    metavar='STR')
setup_group.add_argument("-p", "--password",
                    help="Synapse password",
                    metavar='STR')
activities_group = parser.add_argument_group('activities')
activities_group.add_argument("--phonation",
                    help="Synapse table ID for phonation data",
                    metavar='STR')
activities_group.add_argument("--balance",
                    help="Synapse table ID for balance data",
                    metavar='STR')
activities_group.add_argument("--tapping",
                    help="Synapse table ID for tapping data",
                    metavar='STR')
outputs_group = parser.add_argument_group('outputs')
outputs_group.add_argument("-o", "--output",
                    help='output folder (if not $HOME/mhealthx_output)',
                    default=os.path.join(os.environ['HOME'],
                                         'mhealthx_output'), metavar='STR')
outputs_group.add_argument("-c", "--cache",
                    help="cache folder"
                         " (if not $HOME/mhealthx_cache)",
                    default=os.path.join(os.environ['HOME'],
                                         'mhealthx_cache'), metavar='STR')
args = parser.parse_args()
username = args.username
password = args.password
thirdparty = args.thirdparty
synID_phonation = args.phonation
synID_balance = args.balance
synID_tapping = args.tapping
if args.numproc:
    nproc = args.numproc
else:
    nproc = 1

# ============================================================================
#
# Login once to Synapse and cache credentials
#
# ============================================================================
import synapseclient
syn = synapseclient.Synapse()
syn.login(username, password, rememberMe=True)

# ============================================================================
#
# Initialize main workflow and create output directories
#
# ============================================================================
main_workflow_name = 'mhealthx'
Flow = Workflow(name=main_workflow_name)
Flow.base_dir = args.cache
Sink = Node(DataSink(), name='Results')
Sink.inputs.base_directory = args.output
if not os.path.isdir(args.output):
    print("Create missing output directory: {0}".format(args.output))
    os.makedirs(args.output)
if not os.path.isdir(args.cache):
    print("Create missing cache directory: {0}".format(args.cache))
    os.makedirs(args.cache)
# if synID_phonation:
#     phonation_file_path = os.path.join(args.cache, main_workflow_name,
#                                        'phonation_files')
#     if not os.path.isdir(phonation_file_path):
#         os.makedirs(phonation_file_path)

# ============================================================================
#
# Phonation workflow
#
# ============================================================================
if synID_phonation:
    #phonFlow = Workflow(name='mhealthx phonation pipeline')

    # ------------------------------------------------------------------------
    # Retrieve audio files from Synapse table:
    # ------------------------------------------------------------------------
    GetPhonationRows = Node(name='retrieve_phonation_rows',
                            interface=Fn(function=extract_rows,
                                         input_names=['synapse_table',
                                                      'limit',
                                                      'username',
                                                      'password'],
                                         output_names=['row_as_map_list']))
    Flow.add_nodes([GetPhonationRows])
    GetPhonationRows.inputs.synapse_table = synID_phonation
    GetPhonationRows.inputs.limit = 3
    GetPhonationRows.inputs.username = ''
    GetPhonationRows.inputs.password = ''

    GetPhonation = MapNode(name='retrieve_phonation_file',
                           iterfield='row_as_map',
                           interface=Fn(function=read_files_from_row,
                                        input_names=['synapse_table',
                                                     'row_as_map',
                                                     'column_name',
                                                     'out_path',
                                                     'username',
                                                     'password'],
                                        output_names=['row_as_map',
                                                      'filepath_map',
                                                      'filepath']))
    Flow.add_nodes([GetPhonation])
    GetPhonation.inputs.synapse_table = synID_phonation
    Flow.connect(GetPhonationRows, 'row_as_map_list',
                 GetPhonation, 'row_as_map')
    GetPhonation.inputs.column_name = 'audio_audio.m4a' #'audio_countdown.m4a'
    GetPhonation.inputs.out_path = '.' #phonation_file_path
    GetPhonation.inputs.username = ''
    GetPhonation.inputs.password = ''

    # ------------------------------------------------------------------------
    # Append file names with ".m4a":
    # ------------------------------------------------------------------------
    RenamePhonation = MapNode(name='rename_phonation_file',
                              iterfield='old_file',
                              interface=Fn(function=rename_file,
                                           input_names=['old_file',
                                                        'new_filename',
                                                        'new_path',
                                                        'suffix',
                                                        'copy_file'],
                                           output_names=['renamed_file']))
    Flow.add_nodes([RenamePhonation])
    Flow.connect(GetPhonation, 'filepath', RenamePhonation, 'old_file')
    RenamePhonation.inputs.new_filename = ''
    RenamePhonation.inputs.new_path = ''
    RenamePhonation.inputs.suffix = '.m4a'
    RenamePhonation.inputs.copy_file = True

    # ------------------------------------------------------------------------
    # Convert voice files to .wav format:
    # ------------------------------------------------------------------------
    ConvertPhonation = MapNode(name='convert_phonation_file',
                               iterfield='old_file',
                               interface=Fn(function=convert_audio_file,
                                            input_names=['old_file',
                                                         'file_append',
                                                         'command',
                                                         'input_args',
                                                         'output_args'],
                                            output_names=['converted_file']))
    Flow.add_nodes([ConvertPhonation])
    Flow.connect(RenamePhonation, 'renamed_file',
                 ConvertPhonation, 'old_file')
    ConvertPhonation.inputs.file_append = '.wav'
    ConvertPhonation.inputs.command = os.path.join(thirdparty,
                                                   'ffmpeg', 'ffmpeg')
    ConvertPhonation.inputs.input_args = '-i'
    ConvertPhonation.inputs.output_args = '-ac 2'

    # ------------------------------------------------------------------------
    # Append file names with ".csv":
    # ------------------------------------------------------------------------
    RenamePhonation2 = MapNode(name='rename_converted_phonation_file',
                               iterfield='old_file',
                               interface=Fn(function=rename_file,
                                            input_names=['old_file',
                                                         'new_filename',
                                                         'new_path',
                                                         'suffix',
                                                         'copy_file'],
                                            output_names=['new_file_name']))
    Flow.add_nodes([RenamePhonation2])
    Flow.connect(ConvertPhonation, 'converted_file',
                 RenamePhonation2, 'old_file')
    RenamePhonation2.inputs.new_filename = ''
    RenamePhonation2.inputs.new_path = ''
    RenamePhonation2.inputs.suffix = '.csv'
    RenamePhonation2.inputs.copy_file = False

    # ------------------------------------------------------------------------
    # Process inputs to command:
    # ------------------------------------------------------------------------
    OpenSMILE = MapNode(name='openSMILE',
                        iterfield=['arg1', 'argN'],
                        interface=Fn(function=run_command,
                                     input_names=['command',
                                                  'flag1',
                                                  'arg1',
                                                  'flags',
                                                  'args',
                                                  'flagN',
                                                  'argN',
                                                  'closing'],
                                     output_names=['command_line',
                                                   'args',
                                                   'arg1',
                                                   'argN']))
    Flow.add_nodes([OpenSMILE])
    OpenSMILE.inputs.command = os.path.join(thirdparty, 'openSMILE',
                                            'SMILExtract')
    OpenSMILE.inputs.flag1 = '-I'
    Flow.connect(ConvertPhonation, 'converted_file', OpenSMILE, 'arg1')
    OpenSMILE.inputs.flags = '-C'
    OpenSMILE.inputs.args = os.path.join(thirdparty, 'openSMILE', 'config',
                                                     'IS13_ComParE.conf')
    OpenSMILE.inputs.flagN = '-O'
    Flow.connect(RenamePhonation2, 'new_file_name', OpenSMILE, 'argN')
    # Flow.connect(ConvertPhonation, ('converted_file', rename_file,
    #                                 'ssss', './', '.csv'),
    #              OpenSMILE, 'argN')
    OpenSMILE.inputs.closing = ''
    #Flow.connect(OpenSMILE, 'argN', Sink, 'phonation.@rawfeatures.openSMILE')

    # ------------------------------------------------------------------------
    # Format openSMILE output:
    # ------------------------------------------------------------------------
    FormatOpenSMILE = MapNode(name='format_openSMILE_output',
                              iterfield=['arff_file'],
                              interface=Fn(function=arff_to_csv,
                                           input_names=['arff_file',
                                                        'csv_file'],
                                           output_names=['csv_file']))
    Flow.add_nodes([FormatOpenSMILE])
    Flow.connect(OpenSMILE, 'argN', FormatOpenSMILE, 'arff_file')
    FormatOpenSMILE.inputs.csv_file = ''

    # ------------------------------------------------------------------------
    # Create one feature table from the formatted openSMILE output files:
    # ------------------------------------------------------------------------
    SaveOpenSMILE = Node(name='combine_openSMILE_outputs',
                         interface=Fn(function=tables_to_csv,
                                      input_names=['tables',
                                                   'csv_file'],
                                      output_names=['table_data',
                                                    'csv_file']))
    Flow.add_nodes([SaveOpenSMILE])
    Flow.connect(FormatOpenSMILE, 'csv_file', SaveOpenSMILE, 'tables')
    SaveOpenSMILE.inputs.csv_file = 'openSMILE_IS13_ComParE_features.csv'
    Flow.connect(SaveOpenSMILE, 'csv_file', Sink, 'phonation.@features')



    # ------------------------------------------------------------------------
    # Store openSMILE features to its own Synapse table:
    # ------------------------------------------------------------------------
    # SaveOpenSMILE = JoinNode(name='save_openSMILE',
    #                          joinsource='OpenSMILE',
    #                          joinfield='dataframes',
    #                          interface=Fn(function=dataframes_to_csv_file,
    #                                       input_names=['dataframes',
    #                                                    'csv_file'],
    #                                       output_names=['table_data',
    #                                                     'csv_file']))
    # Flow.add_nodes([SaveOpenSMILE])
    # Flow.connect(FormatOpenSMILE, 'feature_table',
    #              SaveOpenSMILE, 'dataframes')
    # SaveOpenSMILE.inputs.csv_file = 'openSMILE_IS13_ComParE.csv'
    # Flow.connect(SaveOpenSMILE, 'csv_file', Sink, 'phonation.@features')

    # ------------------------------------------------------------------------
    # Store openSMILE features to its own Synapse table:
    # FIX: WOULD NEED TO REORGANIZE: | feature | statistical summary | value |
    # ------------------------------------------------------------------------
    # SaveOpenSMILE = Node(name='save_openSMILE',
    #              interface=Fn(function=concatenate_tables_to_synapse_table,
    #                           input_names=['tables',
    #                                        'synapse_project_id',
    #                                        'table_name',
    #                                        'username',
    #                                        'password'],
    #                           output_names=['table_data',
    #                                         'table_name',
    #                                         'synapse_table_id',
    #                                         'synapse_project_id']))
    # Flow.add_nodes([SaveOpenSMILE])
    # Flow.connect(FormatOpenSMILE, 'feature_table', SaveOpenSMILE, 'tables')
    # SaveOpenSMILE.inputs.synapse_project_id = 'syn4899451'
    # SaveOpenSMILE.inputs.table_name = 'Phonation openSMILE feature table'
    # SaveOpenSMILE.inputs.username = ''
    # SaveOpenSMILE.inputs.password = ''

    # ------------------------------------------------------------------------
    # Store openSMILE output file handle to the mPower phonation file table:
    # ------------------------------------------------------------------------
    # StoreOpenSMILE = Node(name='store_openSMILE',
    #                       interface=Fn(function=file_to_synapse_table,
    #                                    input_names=['feature_file',
    #                                                 'raw_feature_file',
    #                                                 'source_file_id',
    #                                                 'provenance_activity_id',
    #                                                 'command_line',
    #                                                 'synapse_table_id',
    #                                                 'username',
    #                                                 'password'],
    #                                    output_names=[]))
    # Flow.add_nodes([StoreOpenSMILE])
    # Flow.connect(SaveOpenSMILE, 'csv_file',
    #              StoreOpenSMILE, 'feature_file')
    # Flow.connect(OpenSMILE, 'argN',
    #              StoreOpenSMILE, 'raw_feature_file')
    # StoreOpenSMILE.inputs.provenance_activity_id = ''
    # #Flow.connect(OpenSMILE, 'argN',
    # #             StoreOpenSMILE, 'source_file_id')
    # StoreOpenSMILE.inputs.source_file_id = ''
    # Flow.connect(OpenSMILE, 'command_line',
    #              StoreOpenSMILE, 'command_line')
    # Flow.connect(GetPhonation, 'synapse_table_id',
    #              StoreOpenSMILE, 'synapse_table_id')
    # StoreOpenSMILE.inputs.username = ''
    # StoreOpenSMILE.inputs.password = ''


# ============================================================================
#
# Run workflows
#
# ============================================================================
if __name__ == '__main__':

    from time import time
    time0 = time()

    # ------------------------------------------------------------------------
    # Workflow configuration: provenance tracking, content hashing, etc.:
    # ------------------------------------------------------------------------
    # config.enable_provenance()
    Flow.config['execution']['hash_method'] = 'content'
    # Flow.config['execution']['use_relative_paths'] = True

    # ------------------------------------------------------------------------
    # Generate a visual graph:
    # ------------------------------------------------------------------------
    graph_vis = args.graph
    if graph_vis:
        if graph_vis == 'exec':
            Flow.write_graph(graph2use=graph_vis, simple_form=False)
        else:
            if graph_vis == 'hier':
                graph_vis = 'hierarchical'
            Flow.write_graph(graph2use=graph_vis)

    # ------------------------------------------------------------------------
    # Debug: http://nipy.org/nipype/users/config_file.html#debug-configuration
    # ------------------------------------------------------------------------
    debug = False
    if debug:
        config.set('logging', 'workflow_level', 'DEBUG')
        logging.update_logging(config)
        Flow.config['execution']['stop_on_first_rerun'] = True
        nproc = 1

    # ------------------------------------------------------------------------
    # Run with or without a plugin:
    # Ex: workflow.run(plugin='SGEGraph',
    #                  plugin_args = {'dont_resubmit_completed_jobs': True})
    # ------------------------------------------------------------------------
    if args.plugin:
        if args.plugin_args:
            Flow.run(plugin=args.plugin, plugin_args=eval(args.plugin_args))
        else:
            Flow.run(plugin=args.plugin)
    elif nproc > 1:
        Flow.run(plugin='MultiProc',
                 plugin_args={'n_procs': nproc})
    else:
        Flow.run()  # Use all processors: Flow.run(plugin='MultiProc')

    print('Done! ({0:0.2f} seconds)'.format(time() - time0))
