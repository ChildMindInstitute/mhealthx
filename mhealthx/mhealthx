#!/usr/bin/env python
"""
This pipeline runs feature extraction on mHealth data stored on Synapse.org.

Example: mhealthx --phonation syn4590865 -d /software

Example: mhealthx --phonation syn4590865 \
                  --balance syn4590866 \
                  --tapping syn4590864 \
                  -d /software -s 3

- First-time use on a given machine: include -u and -p for Synapse login.
- Replace -d argument with path to installed feature extraction software.

For help in using mhealthx ::

    - README file
    - Help on the command line::

        $ mhealthx --help

This file uses Nipype (http://www.nipy.org/nipype/) to create a workflow
environment that enables mhealthx to run in a flexible, modular manner
while storing provenance information.

Authors:
    - Arno Klein, 2015  (arno@sagebase.org)  http://binarybottle.com

Copyright 2015,  Sage Bionetworks (http://sagebase.org), Apache v2.0 License

"""

import os
import sys
import argparse
from nipype import config, logging
from nipype.interfaces.io import DataSink
from nipype.interfaces.utility import Function as Fn
from nipype.pipeline.engine import Workflow, Node
from mhealthx.extractors import openSMILE
from mhealthx.xio import get_convert_audio, get_convert_accel

# ============================================================================
#
# Command-line arguments
#
# ============================================================================
parser = argparse.ArgumentParser(description="""
                    Extract features from mHealth data
                    stored on Sage Bionetwork's Synapse.org.
                    Example: mhealthx --phonation syn4590865 -d /software
                    (-d: path to installed software dependencies; -u, -p:
                    Synapse login for first use on a given machine)
""",
                                 formatter_class = lambda prog:
                                 argparse.HelpFormatter(prog,
                                                        max_help_position=40))
parser.add_argument("-v", "--version", help="version number",
                    action='version', version='%(prog)s 0.1')
parser.add_argument("-n", "--numproc",
                    help='number of processors (default: 1)',
                    type=int, default=1, metavar='INT')
parser.add_argument("-s", "--stop",
                    help='stop at this many rows of the Synapse tables',
                    type=int, metavar='INT', default=sys.maxint)
parser.add_argument("-g", "--graph",
                    help='plot workflow graph: "hier", "flat", "exec"',
                    choices=['hier', 'flat', 'exec'], metavar='STR')
parser.add_argument("--plugin", dest="plugin",
                    default='Linear',
                    help="optional plugin: --plugin PBS")
parser.add_argument("--plugin_args", dest="plugin_args",
                    help="optional plugin arguments:"
                         " --plugin_args \"dict(qsub_args='-q many')\"")
setup_group = parser.add_argument_group('setup')
setup_group.add_argument("-d", "--dependencies",
                         help="path to software dependencies",
                         metavar='STR')
setup_group.add_argument("-u", "--username",
                         help="Synapse username", metavar='STR')
setup_group.add_argument("-p", "--password",
                         help="Synapse password", metavar='STR')
activities_group = parser.add_argument_group('activities')
activities_group.add_argument("--phonation",
                              help="Synapse table ID for phonation data",
                              metavar='STR')
activities_group.add_argument("--balance",
                              help="Synapse table ID for balance data",
                              metavar='STR')
activities_group.add_argument("--tapping",
                              help="Synapse table ID for tapping data",
                              metavar='STR')
outputs_group = parser.add_argument_group('outputs')
outputs_group.add_argument("-o", "--outputs",
                           help='output folder (if not $HOME/mhealthx_output)',
                           default=os.path.join(os.environ['HOME'],
                                                'mhealthx_output'),
                           metavar='STR')
outputs_group.add_argument("-c", "--cache",
                           help="cache folder (if not $HOME/mhealthx_cache)",
                           default=os.path.join(os.environ['HOME'],
                                                'mhealthx_cache'),
                           metavar='STR')
outputs_group.add_argument("-t", "--temp",
                           help='temp folder (if not same as --cache)',
                           metavar='STR')
outputs_group.add_argument("-i", "--inputs",
                           help="input (prep) folder "
                                "(if not $HOME/mhealthx_cache/mhealthxprep)",
                           default=os.path.join(os.environ['HOME'],
                                                'mhealthx_cache',
                                                'mhealthxprep'),
                           metavar='STR')
outputs_group.add_argument('--reports', dest='reports', action='store_true',
                           help='generate nipype reports')
args = parser.parse_args()
username = args.username
password = args.password
dependencies = args.dependencies
if args.temp:
    temporary_path = args.temp
else:
    temporary_path = args.cache
synID_phonation = args.phonation
synID_balance = args.balance
synID_tapping = args.tapping
if args.numproc:
    nproc = args.numproc
else:
    nproc = 1

# ============================================================================
#
# Third-party software setup
#
# ============================================================================
# openSMILE information:
smile_v2_1 = 'openSMILE-2.1.0'
smile_v2_2 = 'openSMILE-2.2rc1'
smile_config1 = 'IS13_ComParE.conf'
smile_config2 = os.path.join('gemaps', 'GeMAPSv01a_core.lld.conf.inc')
smile_string1 = '_features_{0}_{1}'.format(smile_v2_1, smile_config1)
if dependencies:
    smile_config_file1 = os.path.join(dependencies, smile_v2_1,
                                      'config', smile_config1)
else:
    raise Warning("dependencies not set -- cannot run openSMILE!")

# ============================================================================
#
# Login once to Synapse and cache credentials
#
# ============================================================================
import synapseclient
syn = synapseclient.Synapse()
syn.login(username, password, rememberMe=True)

# ============================================================================
#
# Initialize main workflow and create output directories
#
# ============================================================================
main_workflow_name = 'mhealthx'
Flow = Workflow(name=main_workflow_name)
Flow.base_dir = args.cache
Sink = Node(DataSink(), name='Results')
Sink.inputs.base_directory = args.outputs
if not os.path.isdir(args.outputs):
    print("Create missing output directory: {0}".format(args.outputs))
    os.makedirs(args.outputs)
if not os.path.isdir(args.cache):
    print("Create missing cache directory: {0}".format(args.cache))
    os.makedirs(args.cache)
feature_table_path = os.path.join(args.outputs, 'feature_tables')
if not os.path.isdir(feature_table_path):
    os.makedirs(feature_table_path)

# ============================================================================
#
# Phonation (microphone)
#
# ============================================================================
if synID_phonation:

    # ------------------------------------------------------------------------
    # Phonation data:
    # 1. Retrieve each row + audio file from a Synapse table.
    # 2. Convert voice file to .wav format.
    # ------------------------------------------------------------------------
    getPhonation = Node(name='phonation_data',
                        interface=Fn(function=get_convert_audio,
                                     input_names=['synapse_table',
                                                  'row',
                                                  'column_name',
                                                  'convert_file_append',
                                                  'convert_command',
                                                  'convert_input_args',
                                                  'convert_output_args',
                                                  'out_path',
                                                  'username',
                                                  'password'],
                                     output_names=['row',
                                                   'new_file']))
    getPhonation.inputs.synapse_table = synID_phonation
    row_path_phonation = os.path.join(args.inputs, 'row_files_phonation')
    rows_phon = [os.path.join(row_path_phonation, f)
                 for i, f in enumerate(sorted(os.listdir(row_path_phonation)))
                 if i < args.stop
                 and os.path.isfile(os.path.join(row_path_phonation, f))]
    getPhonation.iterables = ("row", rows_phon)
    getPhonation.inputs.column_name = 'audio_audio.m4a'
    getPhonation.inputs.convert_file_append = '.wav'
    getPhonation.inputs.convert_command = 'ffmpeg'
    getPhonation.inputs.convert_input_args = '-y -i'
    getPhonation.inputs.convert_output_args = '-ac 2'
    getPhonation.inputs.out_path = '.'
    getPhonation.inputs.username = ''
    getPhonation.inputs.password = ''

    # ------------------------------------------------------------------------
    # Repeat for phonation countdown data:
    # ------------------------------------------------------------------------
    getPhonation0 = getPhonation.clone('phonation_countdown_data')
    getPhonation0.inputs.column_name = 'audio_countdown.m4a'

    # ------------------------------------------------------------------------
    # openSMILE on phonation data:
    # 1. Run openSMILE's SMILExtract audio feature extraction command.
    # 2. Construct a feature row from the original and openSMILE rows.
    # 3. Write the feature row to a table or append to a feature table.
    # ------------------------------------------------------------------------
    SMILEphonation = Node(name='openSMILE_phonation',
                          interface=Fn(function=openSMILE,
                                       input_names=['audio_file',
                                                    'row',
                                                    'command',
                                                    'flag1',
                                                    'flags',
                                                    'flagn',
                                                    'args',
                                                    'closing',
                                                    'table_stem',
                                                    'save_rows'],
                                       output_names=['feature_row',
                                                     'feature_table']))
    Flow.connect(getPhonation, 'new_file', SMILEphonation, 'audio_file')
    Flow.connect(getPhonation, 'row', SMILEphonation, 'row')
    SMILEphonation.inputs.command = 'SMILExtract'
    SMILEphonation.inputs.flag1 = '-I'
    SMILEphonation.inputs.flags = '-C'
    SMILEphonation.inputs.flagn = '-csvoutput'
    SMILEphonation.inputs.args = smile_config_file1
    SMILEphonation.inputs.closing = '-nologfile 1'
    SMILEphonation.inputs.table_stem = \
        os.path.join(feature_table_path, 'phonation{0}'.format(smile_string1))
    SMILEphonation.inputs.save_rows = True

    # ------------------------------------------------------------------------
    # Repeat for phonation countdown data:
    # ------------------------------------------------------------------------
    SMILEphonation0 = SMILEphonation.clone('openSMILE_phonation_countdown')
    Flow.connect(getPhonation0, 'new_file', SMILEphonation0, 'audio_file')
    Flow.connect(getPhonation0, 'row', SMILEphonation0, 'row')
    SMILEphonation0.inputs.table_stem = os.path.join(feature_table_path,
        'phonation_countdown{0}'.format(smile_string1))

# ============================================================================
#
# Balance (accelerometer)
#
# ============================================================================
if synID_balance:

    # ------------------------------------------------------------------------
    # Balance data:
    # 1. Retrieve each row + balance json file from a Synapse table.
    # 2. Convert balance data from json to wav format for each axis.
    # ------------------------------------------------------------------------
    getBalance = Node(name='balance_data_to_audio',
                      interface=Fn(function=get_convert_accel,
                                   input_names=['synapse_table',
                                                'row',
                                                'column_name',
                                                'amplitude',
                                                'out_path',
                                                'username',
                                                'password'],
                                   output_names=['row',
                                                 'xfile',
                                                 'yfile',
                                                 'zfile']))
    getBalance.inputs.synapse_table = synID_balance
    row_path_balance = os.path.join(args.inputs, 'row_files_balance')
    rows_bal = [os.path.join(row_path_balance, f)
                for i, f in enumerate(sorted(os.listdir(row_path_balance)))
                if i < args.stop
                and os.path.isfile(os.path.join(row_path_balance, f))]
    getBalance.iterables = ("row", rows_bal)
    getBalance.inputs.column_name = 'accel_walking_rest.json.items'
    getBalance.inputs.amplitude = 32700
    getBalance.inputs.out_path = '.'
    getBalance.inputs.username = ''
    getBalance.inputs.password = ''

    # ------------------------------------------------------------------------
    # Repeat for walking data:
    # ------------------------------------------------------------------------
    getWalking = getBalance.clone('walking_data_to_audio')
    getWalking.inputs.column_name = 'accel_walking_outbound.json.items'

    # ------------------------------------------------------------------------
    # openSMILE on each axis of balance data:
    # 1. Run openSMILE's SMILExtract audio feature extraction command.
    # 2. Construct a feature row from the original and openSMILE rows.
    # 3. Write the feature row to a table or append to a feature table.
    # ------------------------------------------------------------------------
    SMILEbalanceX = Node(name='openSMILE_balance_x',
                         interface=Fn(function=openSMILE,
                                      input_names=['audio_file',
                                                   'row',
                                                   'command',
                                                   'flag1',
                                                   'flags',
                                                   'flagn',
                                                   'args',
                                                   'closing',
                                                   'table_stem',
                                                   'save_rows'],
                                      output_names=['feature_row',
                                                    'feature_table']))
    SMILEbalanceX.inputs.command = 'SMILExtract'
    SMILEbalanceX.inputs.flag1 = '-I'
    SMILEbalanceX.inputs.flags = '-C'
    SMILEbalanceX.inputs.flagn = '-csvoutput'
    SMILEbalanceX.inputs.args = smile_config_file1
    SMILEbalanceX.inputs.closing = '-nologfile 1'
    SMILEbalanceX.inputs.save_rows = True

    #SMILEbalanceX = SMILEphonation.clone('openSMILE_balance_x')
    SMILEbalanceY = SMILEbalanceX.clone('openSMILE_balance_y')
    SMILEbalanceZ = SMILEbalanceX.clone('openSMILE_balance_z')
    Flow.connect(getBalance, 'xfile', SMILEbalanceX, 'audio_file')
    Flow.connect(getBalance, 'yfile', SMILEbalanceY, 'audio_file')
    Flow.connect(getBalance, 'zfile', SMILEbalanceZ, 'audio_file')
    Flow.connect(getBalance, 'row', SMILEbalanceX, 'row')
    Flow.connect(getBalance, 'row', SMILEbalanceY, 'row')
    Flow.connect(getBalance, 'row', SMILEbalanceZ, 'row')
    SMILEbalanceX.inputs.table_stem = \
        os.path.join(feature_table_path, 'balance_x{0}'.format(smile_string1))
    SMILEbalanceY.inputs.table_stem = \
        os.path.join(feature_table_path, 'balance_y{0}'.format(smile_string1))
    SMILEbalanceZ.inputs.table_stem = \
        os.path.join(feature_table_path, 'balance_z{0}'.format(smile_string1))

    # ------------------------------------------------------------------------
    # Repeat for walking data:
    # ------------------------------------------------------------------------
    SMILEwalkingX = SMILEbalanceX.clone('openSMILE_walking_x')
    SMILEwalkingY = SMILEbalanceX.clone('openSMILE_walking_y')
    SMILEwalkingZ = SMILEbalanceX.clone('openSMILE_walking_z')
    SMILEwalkingX.inputs.feature_table_prepend = 'walking_x-axis_features_'
    SMILEwalkingY.inputs.feature_table_prepend = 'walking_y-axis_features_'
    SMILEwalkingZ.inputs.feature_table_prepend = 'walking_z-axis_features_'
    Flow.connect(getWalking, 'row', SMILEwalkingX, 'row')
    Flow.connect(getWalking, 'row', SMILEwalkingY, 'row')
    Flow.connect(getWalking, 'row', SMILEwalkingZ, 'row')
    Flow.connect(getWalking, 'xfile', SMILEwalkingX, 'audio_file')
    Flow.connect(getWalking, 'yfile', SMILEwalkingY, 'audio_file')
    Flow.connect(getWalking, 'zfile', SMILEwalkingZ, 'audio_file')
    SMILEwalkingX.inputs.table_stem = \
        os.path.join(feature_table_path, 'walking_x{0}'.format(smile_string1))
    SMILEwalkingY.inputs.table_stem = \
        os.path.join(feature_table_path, 'walking_y{0}'.format(smile_string1))
    SMILEwalkingZ.inputs.table_stem = \
        os.path.join(feature_table_path, 'walking_z{0}'.format(smile_string1))


# ============================================================================
#
# Run workflows
#
# ============================================================================
if __name__ == '__main__':

    from time import time
    time0 = time()

    # ------------------------------------------------------------------------
    # Workflow configuration: provenance tracking, content hashing, etc.:
    # ------------------------------------------------------------------------
    # config.enable_provenance()
    Flow.config['execution']['hash_method'] = 'timestamp'
    Flow.config['execution']['local_hash_check'] = False
    Flow.config['execution']['create_report'] = args.reports

    # ------------------------------------------------------------------------
    # Generate a visual graph:
    # ------------------------------------------------------------------------
    graph_vis = args.graph
    if graph_vis:
        if graph_vis == 'exec':
            Flow.write_graph(graph2use=graph_vis, simple_form=False)
        else:
            if graph_vis == 'hier':
                graph_vis = 'hierarchical'
            Flow.write_graph(graph2use=graph_vis)

    # ------------------------------------------------------------------------
    # Debug: http://nipy.org/nipype/users/config_file.html#debug-configuration
    # ------------------------------------------------------------------------
    debug = False
    if debug:
        config.set('logging', 'workflow_level', 'DEBUG')
        logging.update_logging(config)
        Flow.config['execution']['stop_on_first_rerun'] = True
        nproc = 1

    # ------------------------------------------------------------------------
    # Run with or without a plugin:
    # Ex: workflow.run(plugin='SGEGraph',
    #                  plugin_args = {'dont_resubmit_completed_jobs': True})
    # ------------------------------------------------------------------------
    if args.plugin:
        if args.plugin_args:
            Flow.run(plugin=args.plugin, plugin_args=eval(args.plugin_args))
        else:
            Flow.run(plugin=args.plugin)
    elif nproc > 1:
        Flow.run(plugin='MultiProc',
                 plugin_args={'n_procs': nproc})
    else:
        Flow.run()  # Use all processors: Flow.run(plugin='MultiProc')

    print('Done! ({0:0.2f} seconds)'.format(time() - time0))




# ------------------------------------------------------------------------
# Store openSMILE features to its own Synapse table:
# ------------------------------------------------------------------------
# SaveOpenSMILE = JoinNode(name='save_openSMILE',
#                          joinsource='OpenSMILE',
#                          joinfield='dataframes',
#                          interface=Fn(function=dataframes_to_csv_file,
#                                       input_names=['dataframes',
#                                                    'csv_file'],
#                                       output_names=['table_data',
#                                                     'csv_file']))
# Flow.connect(FormatOpenSMILE, 'feature_table',
#              SaveOpenSMILE, 'dataframes')
# SaveOpenSMILE.inputs.csv_file = 'openSMILE_IS13_ComParE.csv'
# Flow.connect(SaveOpenSMILE, 'csv_file', Sink, 'phonation.@features')

# ------------------------------------------------------------------------
# Store openSMILE features to its own Synapse table:
# FIX: WOULD NEED TO REORGANIZE: | feature | statistical summary | value |
# ------------------------------------------------------------------------
# SaveOpenSMILE = Node(name='save_openSMILE',
#              interface=Fn(function=concatenate_tables_to_synapse_table,
#                           input_names=['tables',
#                                        'synapse_project_id',
#                                        'table_name',
#                                        'username',
#                                        'password'],
#                           output_names=['table_data',
#                                         'table_name',
#                                         'synapse_table_id',
#                                         'synapse_project_id']))
# Flow.connect(FormatOpenSMILE, 'feature_table', SaveOpenSMILE, 'tables')
# SaveOpenSMILE.inputs.synapse_project_id = 'syn4899451'
# SaveOpenSMILE.inputs.table_name = 'Phonation openSMILE feature table'
# SaveOpenSMILE.inputs.username = ''
# SaveOpenSMILE.inputs.password = ''

# ------------------------------------------------------------------------
# Store openSMILE output file handle to the mPower phonation file table:
# ------------------------------------------------------------------------
# StoreOpenSMILE = Node(name='store_openSMILE',
#                       interface=Fn(function=file_to_synapse_table,
#                                    input_names=['feature_file',
#                                                 'raw_feature_file',
#                                                 'source_file_id',
#                                                 'provenance_activity_id',
#                                                 'command_line',
#                                                 'synapse_table_id',
#                                                 'username',
#                                                 'password'],
#                                    output_names=[]))
# Flow.connect(SaveOpenSMILE, 'csv_file',
#              StoreOpenSMILE, 'feature_file')
# Flow.connect(OpenSMILE, 'argn',
#              StoreOpenSMILE, 'raw_feature_file')
# StoreOpenSMILE.inputs.provenance_activity_id = ''
# #Flow.connect(OpenSMILE, 'argn',
# #             StoreOpenSMILE, 'source_file_id')
# StoreOpenSMILE.inputs.source_file_id = ''
# Flow.connect(OpenSMILE, 'command_line',
#              StoreOpenSMILE, 'command_line')
# Flow.connect(PrepPhonation, 'synapse_table_id',
#              StoreOpenSMILE, 'synapse_table_id')
# StoreOpenSMILE.inputs.username = ''
# StoreOpenSMILE.inputs.password = ''

